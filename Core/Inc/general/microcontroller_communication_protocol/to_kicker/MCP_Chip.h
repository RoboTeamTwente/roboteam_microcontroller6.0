// AUTOGENERATED. Run generator/main.py to regenerate
/*
[  0   ] [  1   ]
11111111 -------- ack_number
-------- 1111---- shootPower
*/

#ifndef __MCP_CHIP_H
#define __MCP_CHIP_H

#include <stdbool.h>
#include <stdint.h>
#include "MCP_BaseTypes.h"

typedef struct _MCP_ChipPayload {
    uint8_t payload[MCP_PACKET_SIZE_MCP_CHIP];
} MCP_ChipPayload;

typedef struct _MCP_Chip {
    uint32_t   ack_number          ; // integer [0, 255]             acknowledgements
    float      shootPower          ; // float   [0.000, 6.500]       desired speed of the ball
} MCP_Chip;

// ================================ GETTERS ================================
static inline uint32_t MCP_Chip_get_ack_number(MCP_ChipPayload *mcpcp){
   return ((mcpcp->payload[0]));
}

static inline float MCP_Chip_get_shootPower(MCP_ChipPayload *mcpcp){
    uint32_t _shootPower = ((mcpcp->payload[1] & 0b11110000) >> 4);
    return (_shootPower * 0.4333333333333333F);
}

// ================================ SETTERS ================================
static inline void MCP_Chip_set_ack_number(MCP_ChipPayload *mcpcp, uint32_t ack_number){
    mcpcp->payload[0] = ack_number;
}

static inline void MCP_Chip_set_shootPower(MCP_ChipPayload *mcpcp, float shootPower){
    uint32_t _shootPower = (uint32_t)(shootPower / 0.4333333333333333F);
    mcpcp->payload[1] = ((_shootPower << 4) & 0b11110000) | (mcpcp->payload[1] & 0b00001111);
}

// ================================ ENCODE ================================
static inline void encodeMCP_Chip(MCP_ChipPayload *mcpcp, MCP_Chip *mcpc){
    MCP_Chip_set_ack_number          (mcpcp, mcpc->ack_number);
    MCP_Chip_set_shootPower          (mcpcp, mcpc->shootPower);
}

// ================================ DECODE ================================
static inline void decodeMCP_Chip(MCP_Chip *mcpc, MCP_ChipPayload *mcpcp){
    mcpc->ack_number     = MCP_Chip_get_ack_number(mcpcp);
    mcpc->shootPower     = MCP_Chip_get_shootPower(mcpcp);
}

#endif /*__MCP_CHIP_H*/
